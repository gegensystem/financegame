<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktives 3D-Modell einer Spritzgießmaschine</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #f0f0f0; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            color: #333;
            font-size: 16px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        .control-btn {
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #btn-open {
            background-color: #28a745; /* Grün */
        }
        #btn-open:hover {
            background-color: #218838;
        }
        #btn-close {
            background-color: #dc3545; /* Rot */
        }
        #btn-close:hover {
            background-color: #c82333;
        }
        #chart-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">Linke Maustaste: Drehen | Mausrad: Zoomen | Rechte Maustaste: Verschieben</div>
    <div id="controls">
        <button id="btn-open" class="control-btn">Öffnen</button>
        <button id="btn-close" class="control-btn">Schließen</button>
    </div>
    <div id="chart-container">
        <canvas id="position-time-chart"></canvas>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === GRUNDEINSTELLUNGEN ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(12, 8, 16);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // === STEUERUNG ===
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 3, 0);

        // === BELEUCHTUNG ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(-10, 15, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // === MATERIALIEN (ENGEL Design) ===
        const matMachineBase = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const matMachineParts = new THREE.MeshStandardMaterial({ color: 0xe_e_e_e_e_e });
        const matSafety = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
        const matTieBars = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
        const matToggle = new THREE.MeshStandardMaterial({ color: 0x005a9c }); // ENGEL Blau
        const matMold = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.4 }); // Werkzeugstahl

        // === BODEN ===
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshStandardMaterial({ color: 0xe0e0e0 }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // === MODELLBAU ===
        const machineGroup = new THREE.Group();
        scene.add(machineGroup);

        const bed = new THREE.Mesh(new THREE.BoxGeometry(20, 1.5, 6), matMachineBase);
        bed.position.y = 0.75;
        bed.castShadow = true;
        machineGroup.add(bed);

        const clampingUnit = new THREE.Group();
        clampingUnit.position.x = -2;
        machineGroup.add(clampingUnit);

        const platenGeo = new THREE.BoxGeometry(1.5, 5, 5);
        const fixedPlaten = new THREE.Mesh(platenGeo, matMachineParts);
        fixedPlaten.position.set(-5, 3.5, 0);
        clampingUnit.add(fixedPlaten);
        
        const movablePlaten = new THREE.Mesh(platenGeo, matMachineParts);
        movablePlaten.position.set(0, 3.5, 0);
        clampingUnit.add(movablePlaten);
        
        // Werkzeug (Mold)
        const moldGeo = new THREE.BoxGeometry(1.0, 4, 4);
        const fixedMoldHalf = new THREE.Mesh(moldGeo, matMold);
        fixedMoldHalf.position.x = 1.25; // An der Platte befestigen
        fixedPlaten.add(fixedMoldHalf);

        const movableMoldHalf = new THREE.Mesh(moldGeo, matMold);
        movableMoldHalf.position.x = -1.25; // An der Platte befestigen
        movablePlaten.add(movableMoldHalf);

        const endPlaten = new THREE.Mesh(new THREE.BoxGeometry(2, 4.5, 4.5), matMachineParts);
        endPlaten.position.set(6, 3.5, 0);
        clampingUnit.add(endPlaten);

        const tieBarGeo = new THREE.CylinderGeometry(0.2, 0.2, 11, 16);
        const tieBarPositions = [ {y: 5.25, z: 2.25}, {y: 5.25, z: -2.25}, {y: 1.75, z: 2.25}, {y: 1.75, z: -2.25} ];
        tieBarPositions.forEach(pos => {
            const bar = new THREE.Mesh(tieBarGeo, matTieBars);
            bar.rotation.z = Math.PI / 2;
            bar.position.set(0.5, pos.y, pos.z);
            clampingUnit.add(bar);
        });
        
        const toggleSystem = new THREE.Group();
        toggleSystem.position.y = 3.5;
        clampingUnit.add(toggleSystem);
        const armLength = 3.5;
        const armGeo = new THREE.BoxGeometry(armLength, 0.4, 0.4);
        
        const rearArm = new THREE.Mesh(armGeo, matToggle);
        const frontArm = new THREE.Mesh(armGeo, matToggle);
        const actuator = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), matToggle);
        toggleSystem.add(rearArm, frontArm, actuator);

        const injectionUnit = new THREE.Group();
        injectionUnit.position.x = 6;
        machineGroup.add(injectionUnit);
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 8, 32), matMachineParts);
        barrel.rotation.z = Math.PI / 2;
        barrel.position.set(0, 3.5, 0);
        injectionUnit.add(barrel);
        const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.2, 0.8, 32), matTieBars);
        nozzle.rotation.z = Math.PI / 2;
        nozzle.position.set(-4.4, 3.5, 0);
        injectionUnit.add(nozzle);
        const drive = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), matMachineBase);
        drive.position.set(5, 3.5, 0);
        injectionUnit.add(drive);

        const safetyGuard = new THREE.Mesh(new THREE.BoxGeometry(5.2, 4.2, 5.7), matSafety);
        safetyGuard.material.transparent = true;
        safetyGuard.material.opacity = 0.2;
        safetyGuard.position.set(-2.5, 3.5, 0);
        clampingUnit.add(safetyGuard);

        // === DIAGRAMM INITIALISIERUNG ===
        const ctx = document.getElementById('position-time-chart').getContext('2d');
        const positionTimeChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Hub',
                    data: [],
                    borderColor: 'rgb(0, 90, 156)',
                    backgroundColor: 'rgba(0, 90, 156, 0.5)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Zeit (s)' },
                        min: 0
                    },
                    y: {
                        title: { display: true, text: 'Hub (mm)' },
                        min: 0
                    }
                },
                animation: false,
                plugins: { legend: { display: false }, title: { display: true, text: 'Weg-Zeit-Diagramm'} }
            }
        });

        // === ANIMATIONSLOGIK ===
        let targetY = 0.1;
        const openY = 2.5;
        const closedY = 0.1;
        const startTime = performance.now();
        const closedPositionX = endPlaten.position.x - 2 * Math.sqrt(armLength*armLength - closedY*closedY);

        document.getElementById('btn-open').addEventListener('click', () => { targetY = openY; });
        document.getElementById('btn-close').addEventListener('click', () => { targetY = closedY; });

        // === ANIMATIONS-SCHLEIFE ===
        function animate() {
            requestAnimationFrame(animate);

            const currentY = actuator.position.y;
            const newY = THREE.MathUtils.lerp(currentY, targetY, 0.08);
            actuator.position.y = newY;

            const L = armLength;
            const y = newY;
            const half_dx = y < L ? Math.sqrt(L*L - y*y) : 0;
            
            const rearPivotX = endPlaten.position.x;
            const movablePlatenX = rearPivotX - 2 * half_dx;
            const actuatorX = rearPivotX - half_dx;

            movablePlaten.position.x = movablePlatenX;
            actuator.position.x = actuatorX;
            
            const rearPivotPoint = new THREE.Vector3(rearPivotX, 0, 0);
            const frontPivotPoint = new THREE.Vector3(movablePlatenX, 0, 0);
            const kneePoint = new THREE.Vector3(actuatorX, y, 0);

            rearArm.position.copy(rearPivotPoint).add(kneePoint).multiplyScalar(0.5);
            rearArm.lookAt(kneePoint);
            frontArm.position.copy(frontPivotPoint).add(kneePoint).multiplyScalar(0.5);
            frontArm.lookAt(kneePoint);

            // Diagramm aktualisieren
            const currentTime = (performance.now() - startTime) / 1000;
            const currentStroke = movablePlatenX - closedPositionX;
            const chartData = positionTimeChart.data.datasets[0].data;
            
            chartData.push({ x: currentTime, y: currentStroke });
            if (chartData.length > 300) {
                chartData.shift();
            }
            
            if (chartData.length > 1) {
                positionTimeChart.options.scales.x.min = chartData[0].x;
                positionTimeChart.options.scales.x.max = currentTime;
            }

            positionTimeChart.update();

            controls.update();
            renderer.render(scene, camera);
        }

        // === FENSTERGRÖSSE ANPASSEN ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
